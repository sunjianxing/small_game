<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Addictive Dodge — Web</title>
<style>
  html,body{height:100%;margin:0;background:#0b1530;font-family:Inter,Arial,Helvetica,sans-serif;display:flex;align-items:center;justify-content:center}
  #wrap{width:900px;max-width:96vw;background:linear-gradient(180deg,#1c2a52 0%,#0e6ea3 100%);border-radius:16px;padding:18px;box-shadow:0 10px 40px rgba(2,6,23,0.6);color:#fff}
  canvas{display:block;background:transparent;border-radius:10px;box-shadow:0 6px 30px rgba(0,0,0,0.4);width:100%;height:auto}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .btn{background:rgba(255,255,255,0.08);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:pointer;color:#fff}
  .btn:hover{background:rgba(255,255,255,0.12)}
  .center{display:flex;gap:12px;align-items:center}
  .score{font-size:16px}
  .overlay{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#fff}
  .title{font-size:36px;margin-bottom:8px}
  .subtitle{font-size:16px;opacity:0.9;margin-bottom:14px}
  .small{font-size:14px;opacity:0.95}
</style>
</head>
<body>
<div id="wrap">
  <div class="topbar">
    <div class="center">
      <div class="score">Score: <span id="score">0</span></div>
      <div style="width:14px"></div>
      <div class="score">High: <span id="high">0</span></div>
    </div>
    <div class="center">
      <button id="btnStart" class="btn">Start</button>
      <button id="btnPause" class="btn">Pause</button>
    </div>
  </div>
  <div style="position:relative">
    <canvas id="game" width="900" height="600"></canvas>
    <div id="overlay" class="overlay" style="pointer-events:none"></div>
  </div>
  <div style="margin-top:12px;font-size:13px;opacity:0.95">Controls: ← → or A D, or hold left mouse to move. Space/P to pause. Enter to (re)start.</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });

  const W = canvas.width;
  const H = canvas.height;

  // UI
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('high');
  const overlay = document.getElementById('overlay');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');

  // Game state
  let player = { x: W/2, y: H - 90, r: 20, velX:0 };
  let obstacles = [];
  let stars = [];
  let particles = [];
  let spawnTimer = 0;
  let starTimer = 0;
  let spawnInterval = 0.9;
  let timeAlive = 0;
  let score = 0;
  let highscore = parseInt(localStorage.getItem('addictive_dodge_high') || '0', 10);
  let started = false;
  let paused = false;
  let gameOver = false;
  let lastTs = null;
  let useMouse = false;
  let mouseX = player.x;

  highEl.textContent = highscore;

  function reset() {
    player.x = W/2; player.velX = 0;
    obstacles = []; stars = []; particles = [];
    spawnTimer = 0; starTimer = 0; spawnInterval = 0.9; timeAlive = 0;
    score = 0; gameOver = false; paused = false; started = false;
    lastTs = null;
    scoreEl.textContent = 0;
    overlay.innerHTML = '';
    overlay.style.pointerEvents = 'none';
  }

  // Utilities
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function rand(a,b){return a + Math.random()*(b-a);}

  function drawGradient() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'rgb(28,36,74)');
    g.addColorStop(1,'rgb(18,110,163)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function spawnObstacle(difficulty){
    const w = Math.floor(rand(30,120));
    const h = Math.floor(rand(18,40));
    const x = clamp(rand(w/2, W - w/2), w/2, W - w/2);
    const speed = rand(140, 250) * difficulty;
    obstacles.push({x, w, h, y: -h, speed});
  }

  function spawnStar(){
    stars.push({x: rand(30, W-30), y: -30, speed: rand(120,180)});
  }

  function addParticles(x,y,color,count=18,spread=120){
    for(let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      const sp = rand(40, spread);
      particles.push({
        x, y,
        vx: Math.cos(ang)*sp,
        vy: Math.sin(ang)*sp,
        life: rand(0.3,0.8),
        maxLife: rand(0.4,0.9),
        size: rand(1,5),
        color
      });
    }
    if(particles.length>1200) particles.splice(0, particles.length-1200);
  }

  function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx;
    const dy = cy - ny;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  // Input
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'ArrowLeft' || e.key === 'a') { player.velX = -PLAYER_SPEED*60; }
    if(e.key === 'ArrowRight' || e.key === 'd') { player.velX = PLAYER_SPEED*60; }
    if(e.key === ' ' || e.key.toLowerCase()==='p') {
      if(started && !gameOver) { paused = !paused; showPauseOverlay(paused); }
    }
    if(e.key === 'Enter') {
      if(!started || gameOver) { startGame(); }
      else if(gameOver) { startGame(); }
    }
  });

  window.addEventListener('keyup', (e)=>{
    if(e.key === 'ArrowLeft' || e.key === 'a') { player.velX = 0; }
    if(e.key === 'ArrowRight' || e.key === 'd') { player.velX = 0; }
  });

  canvas.addEventListener('mousedown', (e)=>{
    useMouse = true;
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  });
  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  });
  window.addEventListener('mouseup', ()=>{ useMouse = false; });

  // scaled player speed like original: keep as constant for keyboard
  const PLAYER_SPEED = 7.5; // used when computing clamp limits in code above

  // Draw routines
  function drawPlayer(){
    // shadow
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = 'rgba(8,8,10,0.6)';
    ctx.beginPath();
    ctx.ellipse(player.x, player.y + player.r*0.9, player.r*2, player.r*0.9, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    // body
    ctx.fillStyle = 'rgb(245,245,255)';
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.fill();
    // highlight
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(player.x-6, player.y-8, player.r*0.45, 0, Math.PI*2);
    ctx.stroke();
  }

  function drawObstacle(o){
    ctx.fillStyle = 'rgb(30,35,50)';
    roundRect(ctx, o.x - o.w/2, o.y, o.w, o.h, 6, true, false);
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (typeof r === 'undefined') r = 5;
    if (typeof fill === 'undefined') fill = true;
    if (typeof stroke === 'undefined') stroke = false;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawStar(s){
    ctx.fillStyle = 'rgb(255,215,80)';
    const cx = s.x, cy = s.y;
    ctx.beginPath();
    for(let i=0;i<5;i++){
      const ang = i*(2*Math.PI/5) - Math.PI/2;
      const ang2 = ang + Math.PI/5;
      const r = 8, r2 = 4;
      ctx.lineTo(cx + Math.cos(ang)*r, cy + Math.sin(ang)*r);
      ctx.lineTo(cx + Math.cos(ang2)*r2, cy + Math.sin(ang2)*r2);
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawParticles(dt){
    for(let p of particles){
      const a = clamp(p.life/p.maxLife,0,1);
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(1, p.size*a), 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function updateParticles(dt){
    for(let i = particles.length-1;i>=0;i--){
      const p = particles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 60 * dt;
      if(p.life <= 0) particles.splice(i,1);
    }
  }

  function showOverlay(title, subtitle){
    overlay.style.pointerEvents = 'auto';
    overlay.innerHTML = '<div style="text-align:center">'+
      '<div class="title" style="font-size:34px;font-weight:600;margin-bottom:8px">'+title+'</div>'+
      '<div class="subtitle" style="opacity:0.95">'+subtitle+'</div>'+
      '</div>';
  }

  function showPauseOverlay(isPaused){
    if(isPaused){
      overlay.style.pointerEvents = 'auto';
      overlay.innerHTML = '<div style="text-align:center"><div class="title">PAUSED</div><div class="small">按 Space / P 继续</div></div>';
    } else {
      overlay.style.pointerEvents = 'none';
      overlay.innerHTML = '';
    }
  }

  function gameOverOverlay(){
    overlay.style.pointerEvents = 'auto';
    overlay.innerHTML = '<div style="text-align:center">'+
      '<div class="title">GAME OVER</div>'+
      '<div class="subtitle">得分：'+Math.floor(score)+' &nbsp; 高分：'+highscore+'</div>'+
      '<div style="height:10px"></div>'+
      '<div class="small">按 Enter 或 点击 Start 重玩</div>'+
      '</div>';
  }

  function step(ts){
    if(!lastTs) lastTs = ts;
    let dt = (ts - lastTs) / 1000;
    lastTs = ts;
    if(dt > 0.05) dt = 0.05; // clamp

    if(!paused && started && !gameOver){
      timeAlive += dt;
      score += dt * 1.5;

      // difficulty and spawn interval
      const difficulty = 1 + (timeAlive / 25);
      spawnInterval = Math.max(0.28, 0.9 - difficulty * 0.14);

      spawnTimer += dt;
      if(spawnTimer > spawnInterval){
        spawnTimer = 0;
        if(Math.random() < Math.min(0.35, difficulty*0.06)){
          const clusters = Math.floor(rand(2,4));
          const basex = rand(120, W-120);
          for(let i=0;i<clusters;i++){
            const w = Math.floor(rand(30,120));
            const h = Math.floor(rand(18,40));
            const x = clamp(basex + rand(-140,140), w/2, W-w/2);
            const speed = rand(140,250) * difficulty * rand(0.9,1.4);
            obstacles.push({x, w, h, y:-h, speed});
          }
        } else {
          spawnObstacle(difficulty);
        }
      }

      starTimer += dt;
      if(starTimer > 3.0){
        starTimer = 0;
        if(Math.random() < 0.6) spawnStar();
      }

      // update player: mouse smoothing or keyboard velocity
      if(useMouse){
        const desired = (mouseX - player.x) * 10;
        player.velX += (desired - player.velX) * Math.min(1, dt * 12);
      } else {
        // if velX set by keys, decelerate gently
        player.velX *= (1 - Math.min(1, dt * 10));
      }

      // clamp speed
      const maxSpeed = PLAYER_SPEED * 60;
      player.velX = clamp(player.velX, -maxSpeed, maxSpeed);
      player.x += player.velX * dt;
      player.x = clamp(player.x, player.r, W - player.r);

      // obstacles update
      for(let i = obstacles.length-1; i>=0; i--){
        const o = obstacles[i];
        o.y += o.speed * dt;
        if(o.y > H + 50){
          obstacles.splice(i,1);
          score += 0.6;
        } else if(rectCircleCollide(o.x - o.w/2, o.y, o.w, o.h, player.x, player.y, player.r)){
          addParticles(player.x, player.y, 'rgb(255,80,60)', 40, 220);
          gameOver = true;
          started = true;
          if(Math.floor(score) > highscore){ highscore = Math.floor(score); localStorage.setItem('addictive_dodge_high', highscore); highEl.textContent = highscore; }
          gameOverOverlay();
        }
      }

      // stars update
      for(let i = stars.length-1; i>=0; i--){
        const s = stars[i];
        s.y += s.speed * dt;
        const dx = s.x - player.x, dy = s.y - player.y;
        if(s.y > H + 20){ stars.splice(i,1); }
        else if(dx*dx + dy*dy <= (player.r + 8)*(player.r + 8)){
          score += 7;
          addParticles(s.x, s.y, 'rgb(255,220,80)', 24, 160);
          stars.splice(i,1);
        }
      }

      updateParticles(dt);
    }

    // draw
    drawGradient();

    // faint grid
    ctx.save();
    ctx.globalAlpha = 0.03;
    ctx.fillStyle = '#ffffff';
    for(let i=0;i<W;i+=60){
      ctx.fillRect(i,0,1,H);
    }
    ctx.restore();

    // draw stars
    for(let s of stars) drawStar(s);
    // draw obstacles
    for(let o of obstacles) drawObstacle(o);
    // player
    drawPlayer();
    // particles
    drawParticles();

    // ui update
    scoreEl.textContent = Math.floor(score);

    if(!started && !gameOver){
      // show start overlay
      overlay.style.pointerEvents = 'auto';
      overlay.innerHTML = '<div style="text-align:center"><div class="title">Addictive Dodge</div><div class="subtitle">Avoid blocks, collect stars — Press Enter or Start</div></div>';
    }

    if(!gameOver) requestAnimationFrame(step);
  }

  // Start / Pause handlers
  btnStart.addEventListener('click', ()=>{
    if(!started || gameOver){ startGame(); }
    else { /* already running */ }
  });
  btnPause.addEventListener('click', ()=>{
    if(!started) return;
    paused = !paused;
    showPauseOverlay(paused);
  });

  function startGame(){
    reset();
    started = true;
    paused = false;
    gameOver = false;
    overlay.style.pointerEvents = 'none';
    overlay.innerHTML = '';
    lastTs = null;
    requestAnimationFrame(step);
  }

  // initial overlay and run idle animation
  overlay.style.pointerEvents = 'auto';
  overlay.innerHTML = '<div style="text-align:center"><div class="title">Addictive Dodge</div><div class="subtitle">Avoid blocks, collect stars — Press Enter or Start</div></div>';

  // idle animation: gentle bob of a not-rendered player (visual only)
  let idleTick = 0;
  setInterval(()=>{ if(!started) { idleTick += 0.04; player.x += Math.sin(idleTick) * 0.6; } }, 30);

})();
</script>
</body>
</html>